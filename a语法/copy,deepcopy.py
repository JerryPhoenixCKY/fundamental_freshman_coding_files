# 不是！a = b 不是浅拷贝，而是“引用赋值”（别名）。

# a = b 只是让 a 和 b 指向同一个 list 对象，没有创建任何新对象！
#
# 🔍 举例说明
#

# b = [1, 2, 3]
# a = b # ← 这不是拷贝！只是 a 和 b 都指向同一个列表
#
# print(id(a)) # 例如: 140234567890
# print(id(b)) # 和上面完全一样！
# 修改 a
# a.append(4)
#
# print(b) # 输出: [1, 2, 3, 4] ← b 也被改了！
#
# ✅ 结论：a 和 b 是同一个对象的两个名字（别名），任何通过 a 或 b 的修改都会影响对方。
#
# 🆚 对比：真正的浅拷贝 vs 引用赋值
#
# 操作 是否创建新对象？ a is b 结果 修改 a[0] 会影响 b 吗？
# ------ ------------------ --------------- ----------------------------
# a = b ❌ 否 True ✅ 会（同一对象）
# a = b[:] ✅ 是（新 list） False ❌ 不会（但嵌套可变对象仍会！）
# a = copy.copy(b) ✅ 是 False ❌ 不会（同上）
# ⚠️ 注意：即使使用浅拷贝（如 a = b[:]），如果 b 包含子列表等可变对象，修改子对象仍会影响原对象（这就是浅拷贝的局限性）。
#
# 🧪 示例：a = b vs 浅拷贝
#
# python
# 情况1：引用赋值（a = b）
# b1 = [[1, 2], [3, 4]]
# a1 = b1
# a1[0][0] = 999
# print("引用赋值后 b1:", b1) # [[999, 2], [3, 4]] ← 被改！
# 情况2：浅拷贝
# import copy
# b2 = [[1, 2], [3, 4]]
# a2 = copy.copy(b2) # 或 a2 = b2[:]
# a2[0][0] = 888
# print("浅拷贝后 b2:", b2) # [[888, 2], [3, 4]] ← 依然被改！（因为子列表共享）
# 情况3：深拷贝
# b3 = [[1, 2], [3, 4]]
# a3 = copy.deepcopy(b3)
# a3[0][0] = 777
# print("深拷贝后 b3:", b3) # [[1, 2], [3, 4]] ← 安全！
#
# ✅ 如何正确“复制”一个 list？
#
# 目标 推荐写法
# ------ --------
# 创建新 list（扁平结构） a = b[:] 或 a = list(b)
# 创建新 list（通用，显式） a = copy.copy(b)
# 创建完全独立副本（含嵌套） a = copy.deepcopy(b)
#
# 💡 记忆口诀
# a = b → 同一个东西，改谁都变；
# a = b[:] → 新壳旧核，内层共用；
# deepcopy → 全新克隆，彻底分离。
#
# 总结
# a = b 不是拷贝，是引用绑定。
# 如果你想避免副作用（即不希望修改 a 影响 b），必须使用拷贝操作。
# 根据数据是否嵌套，选择 浅拷贝 或 深拷贝。
#
# 这在函数传参、数据备份、多线程等场景中极其重要！务必分清。
#



#
#
# ⚠️ 三、深拷贝的注意事项（性能与限制）
# 1. 性能开销大
# 深拷贝递归遍历所有嵌套对象，速度慢、内存高。
# 不要对大型对象频繁深拷贝（如百万级数据）。
# ✅ 优化建议：
#
# 只在必要时使用；
# 考虑是否可用 不可变数据结构（如 tuple、frozenset）或 写时复制（Copy-on-Write） 策略。
# 2. 不支持的对象
# 某些对象无法深拷贝，如：
# 文件句柄（open() 返回的对象）
# 网络连接
# 带有 __slots__ 且未定义 __getstate__ 的类
# 循环引用（虽然 deepcopy 能处理，但可能低效）
# python
# 编辑
# import copy
# f = open("test.txt", "w")
# copy.deepcopy(f)  # ❌ 报错：cannot serialize '_io.TextIOWrapper' object